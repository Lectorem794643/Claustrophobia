	Общая идея алгоритма.
Из условия задачи мы можем заметить что все вершины делятся на две группы: проходные и тупиковые. Проходные мы посещаем единожды, тупиковые проходим дважды. Проходными могут быть только вершины, входящие в состав двух маршрутов: маршрут от Start до Key и маршрут от Key до Finish. Заметим два факта:  Finish неизбежно является листом (тупиковой ветвью дерева); Маршруты  Start=>Key и  Key=>Finish могут частично совпадать. Напрашивается вывод: мы можем вычислить всю сумму вершин графа и умножить ее на два, получив тем самым allWay – некий максимальный путь. Затем, вычтя из allWay вершины, которые мы прошли единожды, мы получим пройденное расстояние для конкретно такой связки маршрутов Start=>Key=>Finish. Нам останется перебирать возможные варианты  Finish, каждый раз вычисляя пройденный путь и сравнивая его с текущим минимальным. Таким образом мы найдем самый оптимальный путь.

Стоит отметить, что скорость работы алгоритма напрямую связана с количеством листьев в графе, так как только лист может быть потенциально оптимальным  Finish, следовательно количество листьев = кол-во перебираемых  Finish. Поэтому алгоритм менее эффективен на графах, похожих на «одуванчик» (таких, у узлов которых очень большие ранги и как следствие много листьев).


	Реализация алгоритма.
Буду ссылаться на код в приложении, указывая на строки и название переменных.

Генерация графа происходит в 20 – 35 строке. Первые несколько вершин могут иметь очень большие ранги, так как граф полностью случайный и искусственно я не ограничивал ранги. Единственное условие — новый ранг вершины при прибавлении к текущему количеству вершин не должен выходить за пределы 2000 (ограничение countRoom)

Далее, так как наш граф статический, стоит сразу создать список листьев (deadends) и узлов (вершины ранга больше 1) –  NO_deadends; Ранг соответствует количеству появления вершины в первом и втором столбце матрицы, описывающей граф.

Сценарии генерируются в строке 58-68, это просто случайные числа в пределах 2000 не совпадающие между собой.

Далее в строках 72-95 мы строим первый маршрут Start=>Key. Сами старт и ключ могут быть тупиками, остальные вершины маршрута — очевидно нет. Поэтому поиск маршрута осуществляется в  NO_deadends, куда мы предварительно добавляем  Start и Key если они там отсутствуют по умолчанию. Так как в процессе список вершин будет сокращается, мы создаем вектор routeKey, который изначально равен  NO_deadends. Далее мы проходим по графу и если вершина все еще присутствует в  routeKey, мы начинаем считать ее ранг. Ранг увеличивается только в том случае, если в матрице найдена считаемая вершина и та вершина в которую она ведет присутствует в  routeKey. Таким образом мы плавно обрезаем граф до тех пор, пока не останутся только вершины ранга 2, которые связывают вершины  Start и Key.

Далее в строках кода 97-104 мы определяем, возможно ли вообще завершить игру. Очевидно, что сценарий проигрышный тогда и только тогда, когда ловушка находиться на маршруте от Start до Key. Иными словами мы не можем добраться до Ключа так как попадем в ловушку. 

Если пройти игру возможно, мы вычисляем пройденное расстояние до ключа, просто перебирая вершины с условием что число в первом столбце графа равно числу в маршруте, а также  число во втором столбце графа присутствует в маршруте. Мы как бы смотрим из вершины вниз и если следующая вершина так же в маршруте — делаем шаг и складываем расстояние. 

Далее в строках 119-176 мы повторяем процедуры, описанные выше с целью определить наиболее оптимальный маршрут от Key до Finish. В качестве кандидатов на роль финиша ма рассматриваем все элементы, находящиеся в  deadends, проверяя что наш тупик не равен ключу или старту (там мы уже побывали, обессмыслено заканчивать игру в этих вершинах, даже если они тоже листья).

Стоит обратить внимание на механизм конечного подсчета расстояния. Создается список вершин notOptimalWay в который мы записываем все вершины из Обоих сформированных маршрутов, умножая их на два, но при этом не допуская вторичного обсчета вершин (даже если они накладываются друг на друга в маршрутах. Таким образом мы вычисляем, как наш кусок графа, который представляет собой два слитых маршрута, записан в allway на текущий момент. Затем мы вычитаем из  allway только что вычисленную суму и вместо нее кладем оптимальную. Оптимальная сумма вычисляется путем складывания путей обоих маршрутов. По умолчанию мы считаем оба маршрута однопроходными и не умножаем их ребра на два. При сложении (наложении маршрутов друг на друга) вершины, посещенные дважды задваиваются и становятся двухпроводными автоматически. Таким образом мы «вытаскиваем» из графа полностью задвоенный кусок и кладем вместо него кусок максимально однопроходный, тем самым получая «оптимальный маршрут». В процессе перебора всех тупиков такие оптимальные маршруты сравниваются и самый короткий становиться правильным ответом. 